{"version":3,"sources":["../webpack/bootstrap ed81d02ed759717fa5fc","lib/findRNGWorker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA,UAAU,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0CAA0C;AACjF;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wDAAwD;AAClF;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,mDAAmD","file":"ed81d02ed759717fa5fc.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/SuikodenRNG-React/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ed81d02ed759717fa5fc","function findRNG(area, encounters, rng_val, progress) {\n  // area; { dungeon: boolean, encounterRate: number, tableLength: number }\n  let status = {\n    message: '',\n    progress: 0,\n    done: false,\n  };\n  const startTime = new Date().getTime();\n  if (encounters.length <= 1) { return null; }\n    // Smaller array size is slower but more space efficient. Performance drop should be negligable.\n  const arraySize = 0xffff;\n  const fights = new Array(arraySize);\n  const fightsRNG = new Array(arraySize);\n  let rng = { rng: rng_val, rng2: rng_val >> 16 & 0x7FFF };\n  function isBattle(rng) {\n    return area.dungeon ? isBattleDungeon(rng, area.encounterRate) : isBattleWorldMap(rng, area.encounterRate);\n  }\n  for (let i = 0, index = 0; i < 0xffffffff; i++) {\n    if (isBattle(rng.rng2)) {\n      fights[index] = getEncounterIndex(nextrng(rng.rng), area.tableLength);\n      fightsRNG[index] = rng;\n      index++;\n      if (index === arraySize - 1) {\n        status.message = `Checking group of ${arraySize} fights`;\n        progress ? progress(status) : console.log(status);\n        const result = bayerMoore(fights, encounters, area.tableLength);\n        if (result !== null) {\n          status.done = true;\n          status.result = fightsRNG[result];\n          status.prevBattleRNG = fightsRNG[(result - 1) % arraySize];\n          console.log(fightsRNG[result]);\n          console.log(fightsRNG[(result - 1) % arraySize]);\n          status.message = `Runtime: ${(new Date().getTime() - startTime) / 1000} seconds.`;\n          progress ? progress(status) : console.log(status);\n          return fightsRNG[result];\n        }\n\n        // Takes end of fights and puts it in the beginning for next iteration\n        // Number of fight taken is length of pattern.\n        for (let j = arraySize - encounters.length, k = 0; j < encounters.length; j++, k++) {\n          fights[k] = fights[j];\n          fightsRNG[k] = fights[j];\n        }\n        index = encounters.length;\n        status.message = 'Generating fights to search';\n        progress ? progress(status) : console.log(status);\n      }\n    }\n    rng = nextrng(rng.rng);\n    if (i % 42949672 === 0) {\n      status.message = 'Generating fights to search';\n      status.progress = i / 42949672;\n      progress ? progress(status) : console.log(status);\n    }\n  }\n  if (progress) progress({ progress: 100, message: 'No match found.', done: true });\n  return null;\n}\n\nfunction bayerMoore(input, pattern, max) {\n  // Create bad char array\n  const badChar = new Array(max).fill(-1);\n  for (let j = 0; j < pattern.length - 1; j++) {\n    badChar[pattern[j]] = j;\n  }\n\n  // var pttrnIndx = pattern.length - 1;\n  let i = pattern.length - 1;\n  while (i < input.length) {\n    // check if match\n    let inputIndx = i;\n    let pttrnIndx = pattern.length - 1;\n    while (input[inputIndx] === pattern[pttrnIndx]) {\n      inputIndx--;\n      pttrnIndx--;\n      if (pttrnIndx === -1) {\n        return i - pattern.length + 1;\n      }\n    }\n    const badCharVal = badChar[input[inputIndx]];\n    // console.log('badCharVal:', badCharVal);\n    const jump = badCharVal === -1 ? pattern.length - 1 : pattern.length - badCharVal - 1;\n    i += jump;\n  }\n  return null;\n}\n\nfunction isBattleWorldMap(r2, encounterRate) {\n  const r3 = r2;\n  r2 = r2 >> 8 << 8;\n  r2 = r3 - r2;\n  return r2 < encounterRate;\n}\n\nfunction isBattleDungeon(r2, encounterRate) {\n  const r3 = 0x7F;\n  const mflo = div32ulo(r2, r3);\n  r2 = mflo;\n  r2 = r2 & 0xFF;\n  return r2 < encounterRate;\n}\n\nfunction getEncounterIndex(rng, len) {\n  const r2 = rng.rng2;\n  const r3 = div32ulo(0x7FFF, len);\n  let encounterIndex = div32ulo(r2, r3);\n  while (encounterIndex >= len) {\n    encounterIndex--;\n  }\n  return encounterIndex;\n}\n\nfunction nextrng(rng) {\n  rng = mult32ulo(rng, 0x41c64e6d) + 0x3039;\n  const rng2 = rng >> 16 & 0x7FFF;\n  return { rng, rng2 };\n}\n\nfunction mult32ulo(n, m) {\n  n >>>= 0;\n  m >>>= 0;\n  const nlo = n & 0xffff;\n  const nhi = n - nlo;\n  return (((nhi * m >>> 0) + (nlo * m)) & 0xFFFFFFFF) >>> 0;\n}\n\nfunction div32ulo(n, m) {\n  return Math.floor(n / m) >>> 0;\n}\n\nonmessage = function(e) {\n  const params = e.data;\n  findRNG(params.area, params.encounters, params.rng, (status) => {\n    postMessage(status);\n  });\n}\n// findRNG({ dungeon: true, encounterRate: 2, tableLength: 11 }, [0, 0], 0x12);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/source-map-loader!./src/lib/findRNGWorker.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}